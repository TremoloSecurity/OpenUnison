= Tremolo Security OpenUnison Configuration & Deployment
Tremolo Security, Inc
v1.0.6, 2015-06-20
:toc: left
:source-highlighter: coderay

Copyright 2015, Tremolo Security, Inc.

== Introduction
OpenUnison combines identity services that are most used by applications into
a single system:

* Authentication
* Session Management
* Identity Federation
* User Provisioning
* Access Request Management 

These services are provided by a J2EE application that can be deployed into
any servlet container.  

=== Web Access Manager
When deployed for web access management, OpenUnison is a reverse proxy, sitting
between your users and your web applications.  

image:images/unison-manual-rev-proxy.png[OpenUnison Reverse Proxy]

When a user attempts to access your web application, they'll allways go through
OpenUnison:

. User requests your application
. OpenUnison checks to see if the URL is protected
. If the URL is protected, OpenUnison will check to see if your are authenticated
  .. If you are authenticated, check if authentication level is valid
  .. If you aren't authenticated, or your authentication level isn't valid execute the authentication chain
. OpenUnison checks if you are authorized
. If authorized, OpenUnison can execute a series of filters to manipulate the request or response
. OpenUnison generates a Last Mile token that contains the user's attributes, nonce, time range and the request URI
. The request is sent your application
. The application, deployed with a Last Mile component, validates the Last Mile token and sets the user's context

The reverse proxy model offers several advantages over a typical agent model:

. Performance - Agents need to "phone home" to verify access
. Ease of development - Develoeprs can write applications "in a vacuum" and integrate later
. Ease of deployment - Last Mile components are lighter then typical agents
. Just-In-Time Provisioning - Create accounts in applications before they login 
  
=== User Provisioning System

In addition to web access management, OpenUnison provides a user provisioning system that can be used to build a private IDentity as a Service solution.  The APIs
provided by OpenUnison can be used directly by applications or in conjunction with Tremolo Security Scale to provide an interface for user registration, requesting access
to resources and approving access via workflows.  The data is recorded in an audit database that allows for reporting on who requested access to what and who approved the access.

image:images/scale_architecture.png[Scale and OpenUnison Architecture]

=== LDAP Virtual Directory

OpenUnison integrates MyVirtualDirectory as an internal LDAP Virtual Directory.  The provisioning services provide a limited search capability, but there's no LDAP interface provided.
The configurations used to power the embedded MyVirtualDirectory can be used in a stand alone MyVirtualDirectory server.

== Deploying OpenUnison

OpenUnison is packaged as a Maven web application that can be customized using Maven's overlay plugin.  This makes integration into any DevOps platform very easy, as out of the box
there are only 3 files that need to be created:

. unison.xml - The main OpenUnison configuration file
. unisonKeyStore.jks - The key store for OpenUnison
. myvd.conf - The MyVirtualDirectory configuration file

The is section details how to create these files and deploy them, but not their individual configurations.  The Configuration Reference section details how to configure OpenUnison.

=== Deploy Reverse Proxy

==== Create a Maven Project
As stated above, OpenUnison is most easily deployed using a Maven project.  The first step is to create a simple web application project:

.Create Simple Maven Project
[source,bash]
----
$ mvn archetype:generate -DgroupId=com.mycompany.openunison -DartifactId=openunison -DinteractiveMode=false -DarchetypeArtifactId=maven-archetype-webapp
$ rm openunison/src/main/webapp/index.jsp
$ rm openunison/src/main/webapp/WEB-INF/web.xml
----

Once the project is created, add the Tremolo Security repository, dependencies and overlay plugin:

.Tremolo Security Repository
[source,xml]
----
<repositories>
        <repository>
                <id>Tremolo Security</id>
                <url>https://www.tremolosecurity.com/nexus/content/repositories/releases/</url>
        </repository>
</repositories>
----

.OpenUnison Dependencies
[source,xml]
----
<dependencies>
 <dependency>
  <groupId>com.tremolosecurity.unison</groupId>
  <artifactId>open-unison-webapp</artifactId>
  <version>1.0.6</version>
  <type>war</type>
  <scope>runtime</scope>

 </dependency>
 <dependency>
  <groupId>com.tremolosecurity.unison</groupId>
  <artifactId>open-unison-webapp</artifactId>
  <version>1.0.6</version>
  <type>pom</type>
 </dependency>
</dependencies>
----

.OpenUnison Overlay Plugin
[source,xml]
----
<build>
 <plugins>
  <plugin>
   <artifactId>maven-compiler-plugin</artifactId>
   <version>3.1</version>
   <configuration>
    <source>1.7</source>
    <target>1.7</target>
   </configuration>
  </plugin>
  <plugin>
   <groupId>org.apache.maven.plugins</groupId>
   <artifactId>maven-war-plugin</artifactId>
   <version>2.6</version>
   <configuration>

    <overlays>
     <overlay>
      <groupId>com.tremolosecurity.unison</groupId>
      <artifactId>open-unison-webapp</artifactId>
     </overlay>
    </overlays>
   </configuration>
  </plugin>
 </plugins>
</build>
----

If everything is configured correctly, when your run the package artifact with Maven the target directory will contain a war file that contains the OpenUnison files including JSPs and
libraries.

==== Create the Key Store

All certificates and keys are stored in a key store called unisonKeyStore.jks.  They key store MUST:


* Be a Java Extended Key Store (JCEKS)
* All key passwords must match the key store password

[source, bash]
----
$ keytool -genseckey -alias session-unison -keyalg AES -keysize 256 -storetype JCEKS -keystore src/main/webapp/WEB-INF/unisonKeyStore.jks
Enter keystore password:  
Re-enter new password: 
Enter key password for <session-unison>
 (RETURN if same as keystore password):   
----

This command created a secret key, a static AES256 key.  This generates the key store as well.  The key that we generated will be used for the session we create.

==== Virtual Directory Configuration

OpenUnison uses an embedded version of MyVirtualDirectory to work with user data.  This allows OpenUnison
to work with LDAP directories, databases, Active Directory, web services, etc.  It also provides a powerful mechanism for manipulating identity data.  For instance you
can add attributes to an Active Directory forest without changing the schema.  There are two roots that should be used:

* ou=Tremolo - This is where OpenUnison will look for identity data
* ou=Data - This is where directories may be configured that OpenUnison won't look for identity data

The ou=Data root is useful for configuring joins where the directories being joined are configured under ou=Data and the joiner is configured under ou=Tremolo.  Create a text file called
myvd.props with the following content:

[source,properties]
----
#Global AuthMechConfig
server.globalChain=

server.nameSpaces=rootdse,myvdroot
server.rootdse.chain=dse
server.rootdse.nameSpace=
server.rootdse.weight=0
server.rootdse.dse.className=net.sourceforge.myvd.inserts.RootDSE
server.rootdse.dse.config.namingContexts=o=Tremolo
server.myvdroot.chain=root
server.myvdroot.nameSpace=o=Tremolo
server.myvdroot.weight=0
server.myvdroot.root.className=net.sourceforge.myvd.inserts.RootObject
----

See MyVirtualDirectory's website (http://myvd.sourceforge.net/) for information on how to configure MyVirtualDirectory.


==== Create the OpenUnison XML File

OpenUnison's unison.xml file drives most of the configuration options.  This file is based on an annotated XML Schema file.  While not required, its recommended that the schema file
be used when creating the unison.xml file.  If using an editor such as Eclipse the schema file will make it much easier to navigate the configuration options.  The easiest way to get this file
is to copy it from the build i

[source,bash]
----
$ cp target/war/work/com.tremolosecurity.unison/open-unison-webapp/WEB-INF/tremoloConfig.xsd src/main/webapp/WEB-INF/
----

Once the file is copied, you can create a unison.xml file from the schema file.  At a minimum you must set the myvdConfig, keyStorePath and keyStorePassword elements:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<tns:tremoloConfig xmlns:tns="http://www.tremolosecurity.com/tremoloConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.tremolosecurity.com/tremoloConfig tremoloConfig.xsd ">
  <tns:applications/>
  <tns:myvdConfig>WEB-INF/myvd.conf</tns:myvdConfig>
  <tns:authMechs/>
  <tns:authChains/>
  <tns:resultGroups/>
  <tns:keyStorePath>WEB-INF/unisonKeyStore.jks</tns:keyStorePath>
  <tns:keyStorePassword>password</tns:keyStorePassword>
</tns:tremoloConfig>
----

==== Port Configurations
OpenUnison can translate between internal and external ports.  An internal port is usually going to be 8080 and 8443 since Tomcat
doesn't generally run on a privileged port.  An external port is usually 80 and 443.  This is useful if you are using iptables rules
for port forwarding or a load balancer.  Finally, you can tell OpenUnison to redirect all unsecure requests to a secure port:

.Example unisonService.props
[source,text]
-----
com.tremolosecurity.openunison.forceToSSL=true
com.tremolosecurity.openunison.openPort=8080
com.tremolosecurity.openunison.securePort=8443
com.tremolosecurity.openunison.externalOpenPort=80
com.tremolosecurity.openunison.externalSecurePort=443
-----

==== Create Context Parameters

The next step is to tell OpenUnison where to find the configuration files.  For Tomcat, this is added to META-INF/context.xml:

[source,xml]
-----
<Environment name="unisonConfigPath" value="WEB-INF/unison.xml" type="java.lang.String"/>
<Environment name="unisonLog4jPath" value="WEB-INF/log4j.xml" type="java.lang.String"/>
<Environment name="unisonServiceConfigPath" value="WEB-INF/unisonService.props" type="java.lang.String"/>
-----

At this point, OpenUnison has a minimum configuration for deployment.

=== Deploy Web Services

== Configuring OpenUnison

=== Reverse Proxy

OpenUnison's reverse proxy capability is configured around applications and URLs.  An application is a logical collection of URLs.  Each URL is made up of a sequence of hosts, a collection 
of filters and potential authorization rules.

Before configuring an application you should know:

. Whats the URL of the application going to be?
. What host and port will the application be sitting behind the reverse proxy?
. Do you want SSO with other applications?
. How will your users authenticate?
. How will OpenUnison tell your application who's logged in?

Once you have the answers to these questions you can begin configuring OpenUnison.

=== Authentication Mechanisms (authMechs)
Authentication Mechanisms define the ways in which a user can be authenticated.
Prior to being added to an authentication chain, a mechanism must
be defined in the section. Every
authentication method has its own configuration parameters. See the
Authentication Mechanisms section of the Configuration Reference for configuration options on
specific mechanisms.  Here's an example of the form login mechanism:

[source,xml]
-----
<!--The name attribute is what is referenced in the authentication chain -->
<tns:mechanism name="loginForm">
 <!-- The URI is where the user is sent when its time to authenticate with this mechanism, MUST start with /auth -->
 <tns:uri>/auth/formLogin</tns:uri>
 
 <!-- The class name of the authentication mechanism -->
 <tns:className>com.tremolosecurity.proxy.auth.FormLoginAuthMech</tns:className>
 
 <!-- List of optional initialization parameters for the mechanism -->
 <tns:init>
 </tns:init>
 
 <!-- Optional list of the parameters that are configured on the chain -->
 <tns:params>
  <tns:param>FORMLOGIN_JSP</tns:param>
 </tns:params>
</tns:mechanism>
-----

Once a mechanism is configured, its available to an authentication chain.

=== Authentication Chains (authChains)

Mechanisms are tied to gether in chains that allow for multiple mechanisms to be executed when a user attempts to authenticate.  This way, an application can require multiple mechanisms
for authentication.  For instance, the user may first login with a username and password, but then be required to accept tearms and conditions.  A chain can also be used for multi-factor
authentication.  Once mechanisms are available, they can be added to a chain.  The below XML shows an example chain:

[source,xml]
-----
<!-- The name is how this chain is referenced in the URL -->
<!-- The level defines how strong an authenticaiton should be -->
<!-- The root defines where in the virtual directory OpenUnison should look for users. If not set, OpenUnison will look in o=Tremolo -->
<tns:chain name="formlogin" level="20" root="o=Tremolo">
 <!-- Each mechanism should be listed in the order that they're to be executed in -->
 <tns:authMech>
  <!-- The name attribute of the mechanism -->
  <tns:name>loginForm</tns:name>
  
  <!-- Determines how the mechanism is required.  If "required" then the chain can not succeed without this mechanism succeeding.  If "optional" then the chain can succeed if this mechanism fails -->
  <tns:required>required</tns:required>
  
  <!-- List of optional parameters for the mechanism while executing the chain.  For specific mechanisms, see the Authentication Mechanisms section of  -->
  <tns:params>
   <tns:param name="FORMLOGIN_JSP" value="/auth/forms/defaultForm.jsp"/>
  </tns:params>
 </tns:authMech>
</tns:chain>
-----

==== Authentication Levels

Each chain has an authentication level.  This level is used to determine how "strong" the authentication is.  If a URL is configured with a chain of a certain level, OpenUnison will
respond in one of two ways:

. If the level of the chain on the URL is HIGHER then the level the user is currently authenticated to then the user will be forced to authenticate with the chain configured on the URL
. If the level of the chain on the URL is EQUAL to or LESS then the level the user is currently authenticated to then the user will NOT be forced to re-authenticate

This allows you to mix and match authentication types depending on the user base.  For instance US Federal Government workers have PIV cards, but private industry might have a TOTP
credential.  By using authentication levels you can ensure they have access to the same resources.  A best practice is to assign levels in alignment with NIST 800-63 but in 10s instead
of 1s:

* 0 - Anonymous
* 10 - No level of assurance
* 20 - Some level of assurance
* 30 - Medium level of assurance
* 40 - High level of assurance

This way you can differentiate between different types of authentication in the same category providing some additional room for customization.

=== Result Groups (resultGroups)

A result group is a collection of results that could occur because of an event.  There are four types of events -

* Authentication Success
* Authentication Failure
* Authorization Success
* Authorization Failure

A result can be one of three actions:

* Create a header
* Create a cookie
* Send a redirect

Finally, a result's value may come from one of three sources:

* A user attribute
* A static value
* A custom class (com.tremolosecurity.proxy.results.CustomResult)

The below is an example of a result group configuration:

[source,xml]
-----
<!-- The name attribute is how the resultGroup is referenced in the URL -->
<tns:resultGroup name="OnAzSuccess">
 <!-- Each result should be listed -->
 <tns:result>
  <!-- The type of result, one of cookie, header or redirect -->
  <tns:type>cookie</tns:type>
  
  <!-- The source of the result value, one of user, static, custom -->
  <tns:source>static</tns:source>
  
  <!-- Name of the resuler (in this case a cookie) and the value -->
  <tns:value>urlSuccessCookie=true</tns:value>
 </tns:result>
 <tns:result>
  <tns:type>header</tns:type>
  <tns:source>user</tns:source>
  <tns:value>result-uid=uid</tns:value>
 </tns:result>
 <tns:result>
  <tns:type>cookie</tns:type>
  <tns:source>user</tns:source>
  <tns:value>result-cookie=uid</tns:value>
 </tns:result>
 <tns:result>
  <tns:type>header</tns:type>
  <tns:source>custom</tns:source>
  <tns:value>mycustomheader=com.company.className</tns:value>
 </tns:result>
</tns:resultGroup>
-----


=== Applications (applications)

Once your authentication mechanisms, chains and result groups are configured, you can configure your application.  Each application is broken into:

. URLs
. Cookie Configuration

Each URL comprises the components you'd expect from a URL such as host, path and transformations.  The cookie configuration defines how an application's session is managed.  Below is 
an example application configuration:

[source,xml]
-----
<tns:application name="AzCheck">
  <tns:urls>
   <!-- The regex attribute defines if the proxyTo tag should be interpreted with a regex or not -->
   <!-- The authChain attribute should be the name of an authChain --> 
    <tns:url regex="false" authChain="formlogin">
      <!-- Any number of host tags may be specified to allow for an application to work on multiple hosts.  Additionally an asterick (*) can be specified to make this URL available for ALL hosts -->
      <tns:host>localhost.localdomain</tns:host>
      
      <!-- The filterChain allows for transformations of the request such as manipulating attributes and injecting headers -->
      <tns:filterChain>
      
       <!-- The last mile filter the most secure mechanism OpenUnison has to integrate with a down stream application.  See the Configuration Reference for all of the filters available with OpenUnison.  NOTE: any param listed multiple times will be interpreted as a multi-value attribute -->
       <tns:filter class="com.tremolosecurity.proxy.filters.LastMile">
        <tns:param name="sigKeyAlias" value="lastmile"/>
        <tns:param name="encKeyAlias" value="lastmile"/>
        <tns:param name="sigKeyPass" value="start123"/>
        <tns:param name="encKeyPass" value="start123"/>
        <tns:param name="timeScew" value="60"/>
        <tns:param name="headerName" value="autoidmrequest" />
        <tns:param name="attribs" value="uid=from-assertion-uid"/>
        <tns:param name="attribs" value="sn=from-assertion-sn"/>
        <tns:param name="attribs" value="cn=from-assertion-cn"/>
       </tns:filter>
      </tns:filterChain>
      
      <!-- The URI (aka path) of this URL --> 
      <tns:uri>/echo2/echo</tns:uri>
      
      <!-- Tells OpenUnison how to reach the downstream application.  The ${} lets you set any request variable into the URI, but most of the time ${fullURI} is sufficient -->
      <tns:proxyTo>http://ubuntu14.tremolo.lan${fullURI}</tns:proxyTo>
      
      <!-- List the various results that should happen -->
      <tns:results>
       <tns:azSuccess>AzSuccessHeader</tns:azSuccess>
       
       
       
      </tns:results>
      
      <!-- Determine if the currently logged in user may access the resource.  If ANY rule succeeds, the authorization succeeds. 
          The scope may be one of group, dn, filter, dynamicGroup or custom
          The constraint identifies what needs to be satisfied for the authorization to pass and is dependent on the scope:
            * group - The DN of the group in OpenUnison's virtual directory (must be an instance of groupOfUniqueNames)
            * dn - The base DN of the user or users in OpenUnison's virtual directory
            * dynamicGroup - The DN of the dynamic group in OpenUnison's virtual directory (must be an instance of groupOfUrls)
            * custom - An implementation of com.tremolosecurity.proxy.az.CustomAuthorization -->
      <tns:azRules>
       <tns:rule scope="group" constraint="cn=staticgroup,ou=internal,ou=GenericLDAP,o=Tremolo" />
      </tns:azRules>
      
    </tns:url>
    
    
  </tns:urls>
  
  <!-- The cookie configuration determines how sessions are managed for this application -->
   <tns:cookieConfig>
   <!-- The name of the session cookie for this application.  Applications that want SSO between them should have the same cookie name -->
   <tns:sessionCookieName>autoIdmSession</tns:sessionCookieName>
   
   <!-- The domain of component of the cookie -->
   <tns:domain>localhost.localdomain</tns:domain>
   
   <!-- The URL that OpenUnison will interpret as the URL to end the session -->
   <tns:logoutURI>/echo/logoff</tns:logoutURI>
   
   <!-- The name of the AES-256 key in the keystore to use to encrypt this session -->
   <tns:keyAlias>sessionKey</tns:keyAlias>
   
   <!-- If set to true, the cookie's secure flag is set to true and the browser will only send this cookie over https connections -->
   <tns:secure>false</tns:secure>
   
   <!-- The number of secconds that the session should be allowed to be idle before no longer being valid -->
    <tns:timeout>0</tns:timeout>
  </tns:cookieConfig>
</tns:application>
-----

=== Identity Providers

OpenUnison can act as an identity provider in addition to a reverse proxy.  When an application is an identity provider, it has some minor differences with the reverse proxy:

. The application can have only one URL that starts with /auth/idp/
. URLs have additional configuration points:
.. Attribute mappings
.. Trusts

Attribute mappings are used to determine which (if any) attributes will be included in the assertion.  Trusts are used to establish the connection between the identity provider
and the service provider / relying party.  Below is an example configuration:

[source,xml]
-----
<!-- Setting isApp to false indicates to OpenUnison this is an identity provider, not a proxied application -->
<application name="MyIdP" isApp="false">
            <!-- on a single URL is allowed on an identity provider -->
            <urls>
             <!-- The regex and authChain attributes are ignored -->
                <url regex="false">
                 <!-- Any number of host tags may be specified to allow for an application to work on multiple hosts.  Additionally an asterick (*) can be specified to make this URL available for ALL hosts -->
                    <host>unison.enterprise.com</host>
                    
                    <!-- The filterChain on an IdP is typically used to add attributes to the user prior to mapping into the assertion -->
                    <filterChain/>
                    
                    <!-- The URI MUST start with /auth/idp/ -->
                    <uri>/auth/idp/MyIdP</uri>
                    
                    <!-- List the various results that should happen -->
                    <results>
                        <auSuccess></auSuccess>
                        <auFail>Default Login Failure</auFail>
                        <azSuccess></azSuccess>
                        <azFail>Default Login Failure</azFail>
                    </results>
                    
                    <!-- Determine if the currently logged in user may access the idp.  If ANY rule succeeds, the authorization succeeds. 
              The scope may be one of group, dn, filter, dynamicGroup or custom
              The constraint identifies what needs to be satisfied for the authorization to pass and is dependent on the scope:
                * group - The DN of the group in OpenUnison's virtual directory (must be an instance of groupOfUniqueNames)
                * dn - The base DN of the user or users in OpenUnison's virtual directory
                * dynamicGroup - The DN of the dynamic group in OpenUnison's virtual directory (must be an instance of groupOfUrls)
                * custom - An implementation of com.tremolosecurity.proxy.az.CustomAuthorization -->
                    <azRules>
                        <rule scope="filter" constraint="(objectClass=*)"/>
                    </azRules>
                    
                    <!-- Defines the IdP specific portions of the application -->
                    <idp className="com.tremolosecurity.idp.providers.Saml2Idp">
                     <!-- The alias of the certificate key used to decrypt any inbound encrypted requests -->
                        <params name="encKey" value=""/>
                        
                        <!-- The alias of the certificate to to sign all outbound requests -->
                        <params name="sigKey" value="sigenc-idp-saml2-sig"/>
                        
                        <!-- If set to true, requires all authnRequests to be signed -->
                        <params name="requireSignedAuthn" value=""/>
                        
                        
                        <!-- Determines which attributes to include in the assertion. -->
                        <mappings>
                         <!-- Each mapping focusses on a single attribute
                           targetAttributeName - The name of the attribute that will appear in the assertion
                           sourceType - One of user, static, or composite
                            * user - The name of an existing attribute on the user's object
                            * static - A static value that does not change regardless of the user
                            * composite - A mixture of user and static, allowing for one SAML attribute to be comprised of other attributes and static text.  Attributes are market as "${attributename}"
                           targetAttributeSource - The value to be used based on the sourceType
                         -->
                            <mapping targetAttributeName="uid" targetAttributeSource="uid" sourceType="user"/>
                        </mappings>
                        
                        <!-- Trusts establish a path between the IdP and SP/RP -->
                        <trusts>
                         <!-- The name of the trust, should line up with the entityID in the metadata -->
                            <trust name="https://mysp.partner.com/service/acs">
                             <!-- Where to post assertions to, OpenUnison only supports the HTTP-Post binding -->
        <param name="httpPostRespURL" value="https://mysp.partner.com/service/acs"/>
        
        <!-- The name of the certificate that signed requests will be signed with -->
        <param name="spSigKey" value="verify-test"/>
        
        <!-- The name of the certificate that all outbound requests will be encrypted with -->
        <param name="spEncKey" value=""/>
        
        <!-- If no nameIDFormat is specified in the authnRequest, use this as the default -->
        <param name="defaultNameId" value="urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified"/>
        
        <!-- if no defaultAuthnContextClassRef is specified in the authenRequest is specified use this one by default -->
        <param name="defaultAuthCtx" value="urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport"/>
        
        <!-- Determines if the SP requires signed assertions -->
        <param name="signAssertion" value="false"/>
        
        <!-- Determines if the SP requires signed responses -->
        <param name="signResponse" value="true"/>
        
        <!-- Determines if the SP requires encrypted assertions -->
        <param name="encAssertion" value="false"/>
        
        <!-- Mapping of the nameidFormat=attribute to define which user attribute to use as the source of the nameID, may be listed multiple times for multiple nameIDFormats -->
        <param name="nameIdMap" value="urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified=uid"/>
        
        <!-- Mapping from the authnContextClassRef to the authentication chain name used to authenticate the user -->
        <param name="authCtxMap" value="urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport=Default Login Form"/>
                            </trust>
                        </trusts>
                    </idp>
                </url>
            </urls>
            
            <!-- The cookie configuration determines how sessions are managed for this application -->
            <cookieConfig>
             <!-- The name of the session cookie for this application.  Applications that want SSO between them should have the same cookie name -->
                <sessionCookieName>tremolosession</sessionCookieName>
                
                <!-- The domain of component of the cookie -->
                <domain>unison.enterprise.com</domain>

    <!-- The URL that OpenUnison will interpret as the URL to end the session -->
                <logoutURI>/logout</logoutURI>
                
                <!-- The name of the AES-256 key in the keystore to use to encrypt this session -->
                <keyAlias>session-tremolosession</keyAlias>
                
                <!-- If set to true, the cookie's secure flag is set to true and the browser will only send this cookie over https connections -->
                <secure>false</secure>
                
                <!-- The number of secconds that the session should be allowed to be idle before no longer being valid -->
                <timeout>0</timeout>
            </cookieConfig>
        </application>
-----

==== Custom Authorizations ====

OpenUnison supports custom authorization rules that implement the com.tremolosecurity.proxy.az.CustomAuthorization interface.  Custom authorizations are defined and then referenced by
name in other areas of the OpenUnison configuration.  Below is an example of a custom authorization rule configuration:

[source,xml]
-----
<customAzRules>
 <!-- The name is used to reference the rule configuration -->
 <!-- The className is the implementation of com.tremolosecurity.proxy.az.CustomAuthorization -->
    <azRule name="Manager1" className="com.tremolosecurity.provisioning.az.ManagerAuthorization">
     <!-- The params tag may be listed multiple times with the same name for multi-value parameters -->
        <params name="numLevels" value="1"/>
        <params name="managerID" value="manager"/>
        <params name="managerIDIsDN" value="true"/>
        <params name="allowLowerManagers" value="false"/>
    </azRule>
</customAzRules>
-----

=== Provisioning Services

OpenUnison's provisioning services provide a power and robust solution for user management both on a single application or as a common identity service.  OpenUnison's platform provides:

* Workflow Services - May be used with, or without a stateful audit database
* Queue Integration - Both for reliability and for scalability
* Scheduler - Build on the Quartz open source scheduler, jobs may be configured across a cluster
* Provisioning Targets - Systems that will receive provisioning requests
* Organizations - A way to organize workflows and reports
* Reports - A simple engine for providing report data based on the audit database
* URLs - Generate links for users based on their authorizations
* Audit Database - Track what requests were made, what approvals were made, etc.

These services can be mixed and matched to provide the identity services needed for your needs.

==== Workflows

Workflows in OpenUnison are comprised of a base set of tasks and a custom task that allows for any custom logic that may be needed.  Each workflow is the coding of business logic
into an XML format.  Each workflow should have a specific set of outcomes that align to a business need.  For instance a workflow could be created to add a user to a directory, 
or add a user to a group.  There are two concepts with workflows that need to be stressed:

. Workflows only act on the attributes that are either passed into the workflow or loaded in a task in the workflow.  For instance if you are running a just-in-time provisioning workflow you may load attributs for a SAML2 assertion.  If adding a user to a group you may only care about the user's unique identifier and the group being added.
. Workflows can either run either synchronously OR asynchronously.  When running a request through Scale for instance, you'll want the reliability that comes from leveraging the queue system however for a Just-in-time provisioning workflow you'll prefer to be synchronous so you can predict when changes to the user's accounts will occur.

The workflow format its self uses a tree based structure to define the flow.  This leads to simpler implementations that can easily be scripted for large numbers of workflows that follow
the same pattern.  We specificly did NOT go with a common workflow language such as BPEL or BPM because the power that those XML formats come with also vastly increases the complexity.
We wanted something that didn't require a GUI to write and could easily be scripted to create multiple workflows easily.

In any workflow there will be two type os tasks:

.  Tasks that can have sub tasks
.  Tasks that can NOT have sub tasks

For tasks that CAN have sub tasks the sub tasks are listed as child elements in the XML.  For instance if a an ifAttributeHasValue task is defined, it should have child elements that will
execute when the attribute and value exist on the user.

===== provision

This task is used to push user data to a provisioning target.  This task does NOT support sub tasks.
[source,xml]
-----
<!-- sync - If true, then the target will update the object in the target to match exactly the current user’s object; potentially removing attributes and entitlements on the user’s object in the target. If false, then only the attribute values on the user’s object will be pushed to the target, in essence “overlaying” it onto the provisioning target
     target - The name of the provisioning target 
     setPassword - If set to true this will create a password on the user. Note that not all targets support password, defaults to false --> 
<tns:provision sync="false" target="ldap2" setPassword="false" />
-----

===== ifNotUserExists

This task will execute sub tasks if-and-only-if there is not a user in the internal virtual directory that matches the value of the attribute specified in the current user’s context.
[source,xml]
-----
<tns:ifNotUserExists target="ldap2" uidAttribute="uid">
 <tns:customTask className="com.tremolosecurity.test.util.TestTask">
  <tns:param name="configVal" value="replacecn"/>
  <tns:param name="attrName" value="cn" />
 </tns:customTask>
 <tns:addGroup name="linkedSAMLUsers" />
 <tns:addAttribute name="givenName" value="addedAttrib"/>
 <tns:provision sync="false" target="ldap2" />
 <tns:resync keepExternalAttrs="false" />
</tns:ifNotUserExists>
-----

==== Queueing

==== Scheduler

==== Provisioning Targets

==== Organizations

==== Reports

==== URLs

==== Audit Database

== Configuration Reference
=== MyVD Inserts
=== Authentication Mechanisms
=== Provisioning Tasks
=== Provisioning Custom Tasks
=== Message Listeners
=== Scheduled Jobs